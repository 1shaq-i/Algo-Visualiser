<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Algorithms Visualiser — Zoom & Extra Algorithms</title>
  <style>
    :root{
      --bg:#0b1020;--panel:#121937;--muted:#1a2452;--text:#e8ecff;--accent:#7aa2ff;--accent-2:#4ce0b3;--warn:#ffb454;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 10% -10%,#1b2550 0%,#0b1020 55%),linear-gradient(160deg,#0b1020,#0a0f1e 60%);color:var(--text);font:15px/1.45 Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    h1{font-size:20px;margin:0}
    .app{display:grid;grid-template-columns:320px 1fr;gap:14px;min-height:100%}
    .panel{background:linear-gradient(180deg,var(--panel),#0f1630);border:1px solid #1c2550;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .left{padding:16px 16px 12px;display:flex;flex-direction:column;gap:12px;position:sticky;top:12px;height:calc(100dvh - 24px);margin:12px}
    .right{margin:12px;padding:12px;display:flex;flex-direction:column;gap:12px}
    .toolbar{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px}
    .select, .input, .btn{height:36px;border-radius:10px;border:1px solid #263065;background:#0d1430;color:var(--text)}
    .select, .input{padding:0 10px}
    .btn{padding:0 12px;background:linear-gradient(180deg,#1b2a70,#17245a);cursor:pointer;letter-spacing:.1px}
    .btn:hover{filter:brightness(1.07)}
    .btn.secondary{background:#10183a}
    .btn.ghost{background:transparent;border-color:#223;}
    .btn.warn{background:linear-gradient(180deg,#6b3b00,#512a00);border-color:#915000;color:#ffd8a1}
    .row{display:flex;gap:8px;align-items:center}
    .row.wrap{flex-wrap:wrap}
    .group{display:grid;gap:6px}
    label{opacity:.8;font-size:12px}

    .viz-wrapper{position:relative;min-height:520px;max-height:70dvh;background:linear-gradient(180deg,#0b122c,#0a1127);border:1px solid #1b2550;border-radius:18px;overflow:auto;cursor:grab}
    .viz-wrapper.panning{cursor:grabbing}
    .viz{position:relative;min-height:520px;min-width:100%}
    .badge{display:inline-flex;gap:6px;align-items:center;background:#0f1a44;border:1px solid #28346b;padding:6px 10px;border-radius:999px;font-size:12px}
    .legend{display:flex;gap:8px;flex-wrap:wrap}

    /* Structures */
    .stack, .queue, .list{display:flex;gap:10px;padding:18px}
    .stack{flex-direction:column-reverse;align-items:flex-start}
    .queue, .list{flex-direction:row;align-items:center}

    .node{--c:#778cff;--bg:#0f173a;min-width:48px;min-height:48px;padding:10px 12px;border-radius:12px;border:1px solid color-mix(in oklab,var(--c),#000 50%);background:linear-gradient(180deg,var(--bg),#0c1331);display:flex;align-items:center;justify-content:center;font-weight:600;position:relative;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03),0 6px 18px rgba(0,0,0,.35);transition:transform .18s ease, box-shadow .18s ease, background .2s ease}
    .node.visited{outline:2px solid var(--accent);box-shadow:0 0 0 4px rgba(122,162,255,.15),0 8px 26px rgba(0,0,0,.45)}
    .node.target{outline:2px solid var(--accent-2);box-shadow:0 0 0 5px rgba(76,224,179,.18),0 10px 28px rgba(0,0,0,.5)}
    .pointer{width:28px;height:4px;background:linear-gradient(90deg,#2b386e,transparent);border-radius:999px;position:relative}
    .pointer::after{content:"";position:absolute;right:-4px;top:-4px;border:6px solid transparent;border-left-color:#2b386e}

    /* Tree (absolute positioned) */
    .tree-canvas{position:relative;padding:40px 20px 80px;min-height:520px}
    .edge{position:absolute;height:2px;background:linear-gradient(90deg,#2b376c,#1d2756);transform-origin:left center;opacity:.8}
    .tree-node{position:absolute;}

    .muted{opacity:.75}
    .pill{padding:6px 10px;border-radius:999px;background:#0d1740;border:1px solid #25306b}

    .footer{display:flex;justify-content:space-between;align-items:center;padding:8px 12px}
    .small{font-size:12px}
    .grow{flex:1}
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel left">
      <div class="toolbar">
        <h1>Algorithms Visualiser</h1>
        <span class="badge" id="status">Ready</span>
      </div>

      <div class="group">
        <label for="structure">Data structure</label>
        <select id="structure" class="select">
          <option>Stack</option>
          <option>Queue</option>
          <option>Linked List</option>
          <option selected>Binary Tree</option>
        </select>
      </div>

      <div class="group">
        <label for="values">Values (comma / space separated)</label>
        <div class="row">
          <input id="values" class="input grow" placeholder="e.g. 5, 3, 1, 3, 6" />
          <button class="btn" id="btn-load">Load</button>
        </div>
        <div class="row wrap">
          <button class="btn secondary" id="btn-add">Add</button>
          <button class="btn secondary" id="btn-remove">Remove</button>
          <button class="btn ghost" id="btn-clear">Clear</button>
        </div>
      </div>

      <div class="group">
        <label>Traversal / Search</label>
        <div class="row wrap">
          <select id="algo" class="select grow">
            <optgroup label="Tree">
              <option value="bfs">BFS (level-order)</option>
              <option value="dfs-pre">DFS Preorder</option>
              <option value="dfs-in">DFS Inorder</option>
              <option value="dfs-post">DFS Postorder</option>
            </optgroup>
            <optgroup label="Linear (Stack/Queue/List)">
              <option value="lin">Linear Search</option>
              <option value="bin">Binary Search (sorted)</option>
            </optgroup>
          </select>
          <input id="target" class="input" placeholder="Target (optional)" />
        </div>
        <div class="row wrap">
          <button class="btn" id="btn-run">Run</button>
          <button class="btn secondary" id="btn-step">Step</button>
          <button class="btn secondary" id="btn-reset">Reset</button>
          <button class="btn warn" id="btn-stop">Stop</button>
        </div>
      </div>

      <div class="legend">
        <span class="pill">Visited</span>
        <span class="pill" style="border-color:#1f5f53;background:#0a2a27">Target</span>
        <span class="pill muted">Edges are level connections</span>
      </div>
      <div class="grow"></div>
      <div class="small muted">Tip: Binary Tree builds level-order. Linear search works on Stack/Queue/List; Binary search assumes numeric sorted data and will render a sorted view.</div>
    </aside>

    <main class="panel right">
      <div class="row" style="justify-content:flex-end; gap:8px; padding:0 6px;">
        <button class="btn secondary" id="zoomOut" title="Zoom out">–</button>
        <button class="btn secondary" id="zoomReset" title="Reset zoom">100%</button>
        <button class="btn secondary" id="zoomIn" title="Zoom in">+</button>
      </div>
      <div class="viz-wrapper" id="vizWrapper">
        <div id="zoom" style="--scale:1; transform:scale(var(--scale)); transform-origin:0 0;">
          <div id="viz" class="viz"><!-- dynamic content injected here --></div>
        </div>
      </div>
      <div class="footer small muted">
        <div>Drag to pan. Ctrl/⌘ + scroll to zoom. Animations are simple and clear.</div>
        <div>
          <span class="badge">Speed: <span id="speedLabel">1×</span></span>
          <input id="speed" type="range" min="0.25" max="2" step="0.25" value="1" />
        </div>
      </div>
    </main>
  </div>

  <script>
    const el = (q, root=document) => root.querySelector(q);
    const els = (q, root=document) => [...root.querySelectorAll(q)];

    const structureSel = el('#structure');
    const valuesInput = el('#values');
    const btnLoad = el('#btn-load');
    const btnAdd = el('#btn-add');
    const btnRemove = el('#btn-remove');
    const btnClear = el('#btn-clear');
    const algoSel = el('#algo');
    const targetInput = el('#target');
    const btnRun = el('#btn-run');
    const btnStop = el('#btn-stop');
    const btnStep = el('#btn-step');
    const btnReset = el('#btn-reset');
    const viz = el('#viz');
    const zoomContainer = el('#zoom');
    const vizWrapper = el('#vizWrapper');
    const status = el('#status');
    const speedSlider = el('#speed');
    const speedLabel = el('#speedLabel');
    const zoomInBtn = el('#zoomIn');
    const zoomOutBtn = el('#zoomOut');
    const zoomResetBtn = el('#zoomReset');

    let data = [];
    let displayData = null; // optional temp view for certain algorithms
    let tree = null; // level-order array based tree
    let stepping = false;
    let playing = false;
    let currentIterator = null;
    let visitedSet = new Set();
    let target = null;
    let zoomLevel = 1; // 0.5–2

    const parseValues = (str) => str.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean).map(v=>isNaN(+v)?v:+v);

    const setStatus = (text) => status.textContent = text;

    function render() {
      viz.innerHTML = '';
      visitedSet.clear();
      const type = structureSel.value;
      const src = displayData ?? data;
      if (type === 'Stack') return renderStack(src);
      if (type === 'Queue') return renderQueue(src);
      if (type === 'Linked List') return renderList(src);
      if(!tree || displayData) tree = buildTreeFromArray(src);
      return renderTree();
    }

    function nodeEl(value){
      const n = document.createElement('div');
      n.className = 'node';
      n.textContent = value;
      return n;
    }

    // ===== Stack =====
    function renderStack(arr){
      const wrap = document.createElement('div');
      wrap.className = 'stack';
      (arr||[]).slice().forEach(v=>wrap.appendChild(nodeEl(v)));
      viz.appendChild(wrap);
    }

    // ===== Queue =====
    function renderQueue(arr){
      const wrap = document.createElement('div');
      wrap.className = 'queue';
      (arr||[]).forEach(v=>wrap.appendChild(nodeEl(v)));
      viz.appendChild(wrap);
    }

    // ===== Linked List =====
    function renderList(arr){
      const wrap = document.createElement('div');
      wrap.className = 'list';
      (arr||[]).forEach((v,i)=>{
        const cell = nodeEl(v); cell.style.setProperty('--c','#9aa8ff');
        wrap.appendChild(cell);
        if(i !== (arr?.length||0)-1){
          const p = document.createElement('div'); p.className='pointer'; wrap.appendChild(p);
        }
      });
      viz.appendChild(wrap);
    }

    // ===== Binary Tree (level-order array) =====
    function buildTreeFromArray(arr){
      return arr.slice();
    }

    function layoutTree(arr){
      const canvas = document.createElement('div');
      canvas.className = 'tree-canvas';
      const depth = Math.floor(Math.log2(arr.length)) + 1;
      const widthPerLeaf = 80;
      const totalLeaves = Math.max(1, 1 << (depth-1));
      const totalWidth = Math.max(600, totalLeaves * widthPerLeaf);
      canvas.style.minWidth = totalWidth + 120 + 'px';

      const pos = new Map();
      const place = (idx, x1, x2, y)=>{
        if(idx >= arr.length || arr[idx]===null || arr[idx]===undefined) return;
        const x = (x1+x2)/2;
        pos.set(idx,{x,y});
        const left = 2*idx+1, right = 2*idx+2;
        place(left, x1, x, y+110);
        place(right, x, x2, y+110);
      };
      place(0, 40, totalWidth+40, 40);

      pos.forEach((p, idx)=>{
        const left = 2*idx+1, right = 2*idx+2;
        [left,right].forEach(ch=>{
          if(pos.has(ch)){
            const a = p, b = pos.get(ch);
            const dx = b.x - a.x, dy = b.y - a.y; const len = Math.hypot(dx,dy); const ang = Math.atan2(dy,dx)*180/Math.PI;
            const e = document.createElement('div');
            e.className='edge';
            e.style.left = a.x+24+ 'px';
            e.style.top = a.y+24 + 'px';
            e.style.width = len + 'px';
            e.style.transform = `rotate(${ang}deg)`;
            canvas.appendChild(e);
          }
        })
      });

      pos.forEach((p, idx)=>{
        const n = nodeEl(arr[idx]);
        n.classList.add('tree-node');
        n.style.left = (p.x)+'px';
        n.style.top = (p.y)+'px';
        n.dataset.index = idx;
        canvas.appendChild(n);
      });

      return canvas;
    }

    function renderTree(){
      if(!tree) tree = buildTreeFromArray(data);
      const canvas = layoutTree(tree);
      viz.appendChild(canvas);
    }

    // ===== Traversals =====
    function *bfs(arr){
      const q=[0];
      const seen = new Set();
      while(q.length){
        const i=q.shift();
        if(i>=arr.length || arr[i]==null || seen.has(i)) continue;
        seen.add(i);
        yield i;
        q.push(2*i+1,2*i+2);
      }
    }
    function *dfsPre(arr, i=0){ if(i>=arr.length || arr[i]==null) return; yield i; yield* dfsPre(arr,2*i+1); yield* dfsPre(arr,2*i+2); }
    function *dfsIn(arr, i=0){ if(i>=arr.length || arr[i]==null) return; yield* dfsIn(arr,2*i+1); yield i; yield* dfsIn(arr,2*i+2); }
    function *dfsPost(arr, i=0){ if(i>=arr.length || arr[i]==null) return; yield* dfsPost(arr,2*i+1); yield* dfsPost(arr,2*i+2); yield i; }

    function highlight(idx){ const n = el(`.tree-node[data-index="${idx}"]`); if(n){ n.classList.add('visited'); } }
    function markTarget(idx){ const n = el(`.tree-node[data-index="${idx}"]`); if(n){ n.classList.add('target'); } }
    function clearHighlights(){ els('.node').forEach(n=>n.classList.remove('visited','target')); }
    function highlightLinear(i){ const nodes = els('#viz .node'); const n = nodes[i]; if(n) n.classList.add('visited'); }

    // ===== Controls =====
    btnLoad.addEventListener('click', ()=>{
      const vals = parseValues(valuesInput.value);
      data = vals; displayData=null;
      if(structureSel.value === 'Binary Tree'){ tree = buildTreeFromArray(vals); }
      setStatus('Loaded ' + vals.length + ' value' + (vals.length!==1?'s':''));
      render();
    });

    btnAdd.addEventListener('click', ()=>{
      const [v] = parseValues(valuesInput.value);
      if(v===undefined) return;
      displayData=null;
      if(structureSel.value==='Stack') data.push(v);
      else if(structureSel.value==='Queue' || structureSel.value==='Linked List') data.push(v);
      else { if(!tree) tree=[]; tree.push(v); data = tree.slice(); tree=data; }
      render();
    });

    btnRemove.addEventListener('click', ()=>{
      displayData=null;
      if(structureSel.value==='Stack') data.pop();
      else if(structureSel.value==='Queue' || structureSel.value==='Linked List') data.shift();
      else { if(tree && tree.length) tree.pop(); data = tree.slice(); }
      render();
    });

    btnClear.addEventListener('click', ()=>{ data=[]; tree=null; displayData=null; render(); setStatus('Cleared'); });

    structureSel.addEventListener('change', ()=>{ clearHighlights(); displayData=null; setStatus('Ready'); render(); });

    btnReset.addEventListener('click', ()=>{ stepping=false; playing=false; clearHighlights(); setStatus('Reset'); });

    speedSlider.addEventListener('input', ()=>{ speedLabel.textContent = speedSlider.value + '×'; });

    function getAlgo(){
      const a = algoSel.value;
      if(a==='bfs') return bfs;
      if(a==='dfs-pre') return dfsPre;
      if(a==='dfs-in') return dfsIn;
      if(a==='dfs-post') return dfsPost;
      if(a==='lin') return null;
      if(a==='bin') return null;
      return bfs;
    }

    function ensureTree(){
      if(structureSel.value!=='Binary Tree'){
        setStatus('Traversal runs on Binary Tree. Switching.');
        structureSel.value = 'Binary Tree';
        tree = buildTreeFromArray(displayData ?? (data.length?data:parseValues(valuesInput.value)));
        render();
      }
    }

    function *runner(){
      const mode = algoSel.value;
      target = targetInput.value.trim();
      const numericTarget = target!=='' && !isNaN(+target) ? +target : (target||null);

      if(mode==='lin' || mode==='bin'){
        let arr = (displayData ?? data).slice();
        if(mode==='bin'){
          arr = arr.slice().filter(v=>v!==null && v!==undefined);
          if(arr.some(v=>typeof v!=='number')){ setStatus('Binary Search needs numeric, sorted data.'); return; }
          arr.sort((a,b)=>a-b);
          displayData = arr.slice();
          if(structureSel.value==='Binary Tree') structureSel.value='Linked List';
          clearHighlights();
          render();
        }
        function* linear(){ for(let i=0;i<arr.length;i++){ yield i; } }
        function* binary(){ let lo=0, hi=arr.length-1; while(lo<=hi){ const mid=Math.floor((lo+hi)/2); yield mid; if(numericTarget==null) break; if(arr[mid]===numericTarget) return; if(arr[mid] < numericTarget) lo=mid+1; else hi=mid-1; } }
        const iter = mode==='lin' ? linear() : binary();
        for(const i of iter){
          highlightLinear(i);
          setStatus(`${mode==='lin'?'Linear':'Binary'} search visiting index ${i}${arr[i]!==undefined?` (value ${arr[i]})`:''}`);
          if(numericTarget!=null && arr[i]===numericTarget){ setStatus(`Found target ${numericTarget} at index ${i}`); playing=false; return; }
          if(stepping){ yield 'step'; }
          else { const delay = 700 / parseFloat(speedSlider.value); yield new Promise(r=>setTimeout(r, delay)); }
        }
        setStatus('Search complete');
        playing=false; stepping=false; return;
      }

      // Tree traversals
      ensureTree();
      const arr = tree || [];
      const algo = getAlgo();
      currentIterator = algo(arr);
      if(numericTarget!==null){ arr.forEach((v,i)=>{ if(v===numericTarget) markTarget(i); }); }
      for(const idx of currentIterator){
        highlight(idx);
        setStatus(`${algoSel.options[algoSel.selectedIndex].text} visiting index ${idx} (value ${arr[idx]})`);
        if(numericTarget!==null && arr[idx]===numericTarget){ setStatus(`Found target ${numericTarget} at index ${idx}`); playing=false; return; }
        if(stepping){ yield 'step'; }
        else { const delay = 700 / parseFloat(speedSlider.value); yield new Promise(r=>setTimeout(r, delay)); }
      }
      setStatus('Traversal complete');
      playing=false; stepping=false;
    }

    async function play(){ if(playing) return; playing=true; stepping=false; clearHighlights(); const gen = runner(); for(let n = gen.next(); !n.done; n = gen.next()){ if(!playing){ break; } if(n.value==='step'){ } else if(n.value instanceof Promise){ await n.value; } } playing=false; }

    function prepareStep(){ if(currentIterator==null){ clearHighlights(); stepping=true; const mode=algoSel.value; if(mode==='lin' || mode==='bin'){ currentIterator = runner(); } else { ensureTree(); currentIterator = getAlgo()(tree||[]); } } }

    btnRun.addEventListener('click', play);
    btnStop.addEventListener('click', ()=>{ playing=false; stepping=false; setStatus('Stopped'); });

    btnStep.addEventListener('click', ()=>{
      prepareStep();
      const n = currentIterator.next();
      if(!n.done){
        const idx = n.value;
        if(idx==='step') return;
        if(algoSel.value==='lin' || algoSel.value==='bin') highlightLinear(idx); else highlight(idx);
        if(tree && (algoSel.value!=='lin' && algoSel.value!=='bin')) setStatus(`Step → index ${idx} (value ${tree[idx]})`);
      } else { setStatus('No more steps'); }
    });

    // Zoom controls & pan-to-scroll drag
    function applyZoom(){ zoomContainer.style.setProperty('--scale', zoomLevel.toFixed(2)); zoomResetBtn.textContent = Math.round(zoomLevel*100) + '%'; }
    zoomInBtn.addEventListener('click', ()=>{ zoomLevel = Math.min(2, zoomLevel + 0.1); applyZoom(); });
    zoomOutBtn.addEventListener('click', ()=>{ zoomLevel = Math.max(0.5, zoomLevel - 0.1); applyZoom(); });
    zoomResetBtn.addEventListener('click', ()=>{ zoomLevel = 1; applyZoom(); });

    let isPanning=false, panStartX=0, panStartY=0, startScrollL=0, startScrollT=0;
    vizWrapper.addEventListener('mousedown', (e)=>{ isPanning=true; vizWrapper.classList.add('panning'); panStartX=e.clientX; panStartY=e.clientY; startScrollL=vizWrapper.scrollLeft; startScrollT=vizWrapper.scrollTop; e.preventDefault(); });
    window.addEventListener('mousemove', (e)=>{ if(!isPanning) return; vizWrapper.scrollLeft = startScrollL - (e.clientX - panStartX); vizWrapper.scrollTop = startScrollT - (e.clientY - panStartY); });
    window.addEventListener('mouseup', ()=>{ isPanning=false; vizWrapper.classList.remove('panning'); });

    vizWrapper.addEventListener('wheel', (e)=>{ if(e.ctrlKey || e.metaKey){ e.preventDefault(); const delta = e.deltaY<0? 0.1 : -0.1; zoomLevel = Math.min(2, Math.max(0.5, zoomLevel + delta)); applyZoom(); } }, { passive:false });

    // Initial demo values
    valuesInput.value = '5, 3, 8, 1, 4, 7, 9, 0';
    data = parseValues(valuesInput.value);
    tree = buildTreeFromArray(data);
    render();
    applyZoom();
  </script>
</body>
</html>
